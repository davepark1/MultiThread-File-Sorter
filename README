multiThreadSorter.c:
	My program takes in as inputs the flags, the column to sort by, and input/output directories. The column flag as well as the column to sort by are mandatory, however the input/output directories are optional. If the input/output directories are not provided, the program starts looking for csv files in the current directory, and places the resulting sorted csv file into the current directory. For the input/output directories in particular, the provided directories MUST be real paths to those directories. For example, -o must be "/ilab/users/dhp56/Desktop/sysprog/resultFolder" instead of simply "resultFolder."

	To run the program, all you need to do is compile using the make file and run the program using:

					./multiThreadSorter -c ...

	Going into the design of the program, I created 8 functions to help with finding the csv files and sorting them all into one file: runnable, objDump, merge, mergeSort, checkIfDigit, createObject, createColumns, trim. I also created 3 global variables to help keep track of important information. Mlist is a struct Movie* that holds a linked list of all the movie metadata for all the csv files. Mtail is a struct Movie* that keeps track of the tail of the list so that the critical sections in the program can remain short. Count holds the number of threads but is used to assign unique id's for each thread. Mutexes 1 to 3 were assigned respectively.

	Runnable is a recursive function (it calls itself) that is used to create/run new threads. It takes in a struct Arg, which I use to store multiple useful informations (file type, file name, path), as a void*. Runnable always runs on a new thread. Depending on the file type, it chooses to either open/read the file or enter into the directory. If the file is a directory, I use opendir() on the path that was passed into the function and traverse through the directory. Runnable is called again and a new thread is created for each file or directory that is found. A pthread_join is placed after every thread creation. On the other hand, if the file type that is passed into runnable is a file, runnable calls objDump. Once objDump returns, it locks mutexes 1 and 2 to add the movie metadata into mlist. At the end of each iteration of the loop that traverses through the directory, mutex 3 is locked to increment count and assign a unique tid a thread. At the end of the function, the program will output in stdout the initial PID as well as all the id's of the different threads that were created and the total number of threads created.

	ObjDump is a function that opens the file, after it has been confirmed to be a csv file, and reads each line with fgets. The first line is retrieved and sent to createColumns, where the entire line is separated into columns using strtok_r and returned. All the following lines are sent to createObject, where a new struct Movie is dynamically allocated with a list of the untrimmed metadata and trimmed metadata of the movie. **This is important because I use the trimmed metadata to make comparisons, but print the untrimmed metadata into the output file. I also store the total number of columns available in the particular file and a list of the specific columns that appear in the struct. If the movie metadata happens to contains more data than the total number of columns specified in the file, an error message is printed in stderr and none of the file's movie metadatas are stored in mlist and the program moves onto the next file.

	Merge and mergeSort are functions used to sort the mlist after all the threads have returned and all the movie metadata found have been placed in mlist. It uses the regular mergesort algorithm, however, the way the comparisons are done is a little different. The movie metadata are compared based on their trimmed versions. However, if the data only contains spaces and no other characters, then the comparison is made with the untrimmed version. Also, if the column to be sorted is numerical, I use the checkIfDigit function to check if the data is numerical before converting the value into a digit and making the comparison.


multiThreadSorter.h:
	For the header, I have all the libraries that I imported, the function prototypes used in the source file, and the declaration of structs that I used in my code.

	Struct Movie is the struct that I used to hold the data for each movie. It contains the list of columns that were present in the file in which this movie metadata was found. In addition it contains the trimmed/untrimmed list of the movie metadata as well as the total number of column headers in the file in which this movie metadata was found. Keeping track of this information is important because it helps avoid segmentation faults while writing everything into the output file.

	Struct Arg is the struct that I used to hold the information to be passed onto the next thread. I chose to create a struct for this to avoid having to create unnecessary global variables that might cause problems when multiple threads are trying to access them. This struct holds the file type (file or directory), the file name, and the path to this file or directory.

	Struct Thread is a struct that I created to keep a record of all the threads that are created. By making a struct, I could create a linked list that could grow indefinitely instead of having to allocate a specific amount of memory for an array. This struct only contains the id for a thread.

Difficulties:
	Some of the difficulties that I had was making the threads run as asynchronously as possible. At first, I tried to store a list of the thread id's that were spawned while traversing through the directory, then joining them after the loop. However, this would cause the program to stop for some reason. So instead, I decided to place pthread_joins after every pthread_create.
	In addition, I had some difficulty making sure that the data was correctly read and printed into the output file. For example, sometimes the code would read in "\n" as part of the string, which would mess up the printing into the new file. I fixed this by identifying if the last character in each string contained "\n" and creating a new string excluding the "\n" if it did.
	I also had a hard time understanding exactly how the output on standard out is supposed to look like. I made it so that for every thread, the initial PID, tid's of all threads spawned from that thread, and the total number of threads spawned are printed in stdout. The other option was to have the program output in stdout the initial PID as well as all the id's of the different threads that were created and the total number of threads created at the very end.